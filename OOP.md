В мире программирования можно услышать очень много странных и непонятных сперва аббревиатур. Одна из таких - ООП - скрывает за собой целое поколение программ и программистов, проблем и их решений, а главное - ленивых людей.

Само понятие расшифровывается не сложно - Объектно Ориентированное Программирование. Это _парадигма_ программирования, относящаяся к любой функциональности как к _объекту_ - хранилищу _свойств_ и _методов_. Теперь давайте выяснять, что же это за страшные слова.

# История происхождения

## Структуры
Программы делали достаточно давно. Сначала их делали учёные для произведения сложных и нудных вычислений, которые необходимы были для их исследований. Потом начали появляться программы посложнее и поинтереснее - о компьютерах заговорили не только как о калькуляторах, но и как о машинах, способных делать много разных интересных вещей и сразу.

Через некоторое время компьютеры и программы вышли на очень важный этап развития любой технологии - военное дело. Потом пошла коммерция и рынок. Программы становились всё сложнее и сложнее. Людям перестало хватать стандартных типов данных - чисел (много типов чисел), массивов и булевых значений. Данных становилось всё больше, но смысл не менялся, их нужно было обрабатывать стандартными способами, но все эти переменные запрашивались у операционной системы в часто в разное время и значения раскидывались по памяти в разброс.

```
   [a]
  [$] [c]   [d]
     [S]     [r]
[T]      [f]
    [v]
```

Скорость доступа к таким переменным была маленькая...

Раньше программистам требовалось описывать какое-то состояние чего-либо, например ракеты в какой-нибудь игре, с помощью большого количества переменных - направление киля, скорость и направление ветра, масса, мощьность головки и т. д. Но ракет на складе много, значит нужен массив. Для вычисления направления киля 15 ракет для достижения всеми ими определённой точки нужно, допустим, 3 параметра - скорость ветра, точка запуска, скорость движения ракеты. Для каждой ракеты делать переменные `Vwind_1`, `Vwind_2` и так далее никто не хотел, поэтому они хранились в массиве, где индекс был номером ракеты: `Vwind_i = [10, 200, 35, 47, ...]`. Такой же массив был относительно быстрее и мог хранить много значений в одной переменной.

```
[v:12, 34, 56]   [s:2, 346, 633, 87]
   [r:45, 6916, 7, 473, 3258, ... ]
```

Скорость досутпа была чуть выше, но всё равно все алгоритмы страдали от того, что данные одной ракеты разбросаны не только по памяти, но и по разным переменным, название каждой нужно было знать и помнить её смысл. А если одна из ракет взрывалась? А если игрок поставил турель и она постоянно пускает ракеты - это же ужас! Нужно следить чтобы во всех массивах не просто было одинаковое количество элементов, но и каждый элемент соответствовал элементам в других массивах!

Решением стали структуры - новый тип данных, который состоял из нескольких переменных (свойств), хранящихся в памяти друг рядом с другом. Доступ к значениям этих переменных осуществлялся так же как к элементам массива - по смещение относительно центра в памяти.

Получалось что-то такое:

```
[Vx,Vy,M,X,Y]
```

Такой тип данных прекрасно хранится в массиве, так как каждое свойство имеет свой размер, значит можно узнать и размер всей структуры.

```
[[Vx,Vy,M,X,Y], [Vx,Vy,M,X,Y], ...]
```

А самое главное - теперь всё хранится в одном месте - не нужно думать о нескольких массивах из которых надо удалять элементы.

Так объекты обзавелись _свойствами_.

## Не повторяй свой код!
Теперь, когда есть структуры и данные хранить просто и легко, можно спокойно программировать дальше. Делать ракетницы, солдат, танки и остальную игровую технику, необходимую для расставления на тактическом поле. Каждый тип вооружения теперь хранился в структуре, а все девизии и полки - в массивах. 

Но полки нужно как-то передвигать на поле. Для этого были созданы функции передвижения на каждый тип техники и солдата. Получилось много функций, делающих по сути одно и тоже - изменяющих координаты объектов на поле. Тогда было решено соединить их все в одну функцию `move`, но поскольку объектов много и все разные, внутри этой функции стало слишком много конструкций `if ... else`, просто определяющих скорость объекта. Логично сделать так, чтобы не определять эту скорость в функции каждый раз, а хранить её где-то внутри самого объекта, например в поле `speed`.

Так появилось два очень важное понятие в ООП - базовые свойства. Функция могла принимать на вход любой объект, который имел 3 базовых для этой функции свойства: X, Y и максимальную скорость.

Через какое-то время стало понятно, что на самом деле не нужно каждый раз записывать в объект одно и тоже число - максимальную скорость - и это число стали хранить отдельным свойством (static) в одной переменной, доступ к которой был таким же, как и к любому другому свойству, через название.


## "А давайте вообще всё хранить в одном месте"
До этого программисты уже поняли, что хранить функцию `move` в глобальной области видимости - не хорошо, но и в модуле её хранить как-то не очень приятно.

Теперь у наших ленивых героев в голове появилась гениальная идея: "А давайте будем хранить функцию `move` внутри структур как static-свойство!"

Эти static-свойства, являющиеся функциями теперь называются _методами_.


## Дурная наследственность...
Ещё через какое-то время программистам дали задачу - реализовать танкам повороты, то есть перед тем, как ехать к какой-то точке им нужно было направиться к этой точке передом.

Ещё одна интереснейшая мысль спустилась на головы людей: "Давайте даже сделаем лучше, сделаем одну структуру `Movable`, которая будет иметь `X`, `Y`, `V` и `move` и заставим остальные структуры так же иметь эти свойства! А для `Tank` просто сделаем свою `move`, которая будет сначала поварачиваться, а потом уже и двигаться".

Таким образом появились понятия _предок_ - структура `Movable` - и _наследник_. Смысл был в том, чтобы сделать один функционал для всех и потом _наследовать_ его. А для тех, кому нужны какие-то изменения - создавать новый метод или свойство.
